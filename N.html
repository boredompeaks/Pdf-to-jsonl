<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relationship Psychology Dataset Generator</title>
    <style>
        /* --- Google Font Import --- */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        :root {
            --primary-color: #00bcd4;
            --primary-hover: #0097a7;
            --danger-color: #e53935;
            --danger-hover: #c62828;
            --success-color: #4caf50;
            --success-hover: #388e3c;
            --bg-dark: #090a0f;
            --bg-light: #1b2735;
            --text-primary: #e0e0e0;
            --text-secondary: #bdbdbd;
            --border-color: rgba(255, 255, 255, 0.18);
            --input-bg: rgba(0, 0, 0, 0.3);
            --container-bg: rgba(255, 255, 255, 0.08);
        }

        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            padding: 20px 10px;
            background: radial-gradient(ellipse at bottom, var(--bg-light) 0%, var(--bg-dark) 100%);
            color: var(--text-primary);
            min-height: calc(100vh - 40px);
            overflow-x: hidden;
            box-sizing: border-box;
        }

        .container {
            max-width: 850px;
            margin: auto;
            padding: 30px;
            border-radius: 15px;
            background: var(--container-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 35px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1.5px;
            text-shadow: 0 0 8px rgba(0, 188, 212, 0.5);
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 400;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        input[type="text"],
        input[type="password"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            box-sizing: border-box;
            background-color: var(--input-bg);
            color: var(--text-primary);
            font-size: 0.95em;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Poppins', sans-serif;
        }

        select {
             appearance: none;
             background-image: url('data:image/svg+xml;utf8,<svg fill="%23bdbdbd" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
             background-repeat: no-repeat;
             background-position: right 10px center;
        }

        input::placeholder, textarea::placeholder { color: #757575; }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 8px rgba(0, 188, 212, 0.3);
        }

        textarea {
            height: 250px;
            resize: vertical;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        button {
            background-color: var(--primary-color);
            color: var(--bg-dark);
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-right: 8px;
            font-size: 0.95em;
            font-weight: 600;
            margin-bottom: 10px;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-family: 'Poppins', sans-serif;
        }

        button:hover:not(:disabled) {
            background-color: var(--primary-hover);
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background-color: #555;
            color: #999;
            cursor: not-allowed;
            opacity: 0.7;
        }

        #stopButton { background-color: var(--danger-color); color: #fff; }
        #stopButton:hover:not(:disabled) { background-color: var(--danger-hover); }

        #downloadButton { background-color: var(--success-color); color: #fff; }
        #downloadButton:hover:not(:disabled) { background-color: var(--success-hover); }

        #dropZone {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: border-color 0.3s ease, background-color 0.3s ease;
            color: var(--text-secondary);
        }

        #dropZone.dragover, #dropZone:hover {
            border-color: var(--primary-color);
            background-color: rgba(0, 188, 212, 0.1);
        }

        #fileList { list-style: none; padding: 0; margin: 20px 0; }

        #fileList li {
            background: rgba(255, 255, 255, 0.06);
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 8px;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ccc;
        }

        #fileList li button {
            padding: 3px 8px;
            font-size: 0.8em;
            background-color: rgba(229, 57, 53, 0.6);
            color: #fff;
            box-shadow: none;
            border-radius: 5px;
            margin: 0;
        }

        #status {
            margin-top: 20px;
            color: var(--text-secondary);
            min-height: 1.6em;
            font-size: 0.95em;
            transition: color 0.3s ease;
        }

        .hidden-file-input { display: none; }

        .input-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .button-group { margin: 15px 0; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>

<body>
    <div class="container">
        <h1>Relationship Psychology Dataset Generator</h1>

        <div id="dropZone" onclick="document.getElementById('fileInput').click();">
            Drag & Drop Relationship Psychology PDFs here, or click to select files. (Max 10)
        </div>
        <input type="file" id="fileInput" class="hidden-file-input" multiple accept=".pdf">

        <div class="input-row">
            <div>
                <label for="apiKey">OpenRouter API Key:</label>
                <input type="password" id="apiKey" placeholder="sk-or-...">
            </div>
            <div>
                <label for="modelSelect">Select Model:</label>
                <select id="modelSelect">
                    <option value="qwen/qwen3-235b-a22b:free">Qwen3 235B A22B(Free)</option>
                    <option value="google/gemini-2.0-flash-001">Google Gemini </option>
                    <option value="anthropic/claude-3.5-sonnet">Claude 3.5 Sonnet</option>
                    <option value="google/gemini-flash-1.5">Google Gemini 1.5 Flash</option>
                    <option value="openai/gpt-4o">OpenAI GPT-4o</option>
                    <option value="mistralai/mistral-large">Mistral Large</option>
                    <option value="nousresearch/nous-hermes-2-mixtral-8x7b-dpo">Nous Hermes 2 Mixtral (Free)</option>
                    <option value="google/gemma-2-9b-it:free">Google Gemma 2 9B (Free)</option>
                    <option value="meta-llama/llama-3-8b-instruct:free">Meta Llama 3 8B (Free)</option>
                </select>
            </div>
            <div>
                <label for="targetPairsInput">Target Pairs (0 for unlimited):</label>
                <input type="number" id="targetPairsInput" min="0" value="500" placeholder="e.g., 500">
            </div>
        </div>

        <ul id="fileList"></ul>

        <div class="button-group">
            <button id="startButton">Start Generation</button>
            <button id="stopButton" disabled>Stop</button>
            <button id="downloadButton" disabled>Download JSONL</button>
        </div>

        <div>
            <label for="output">Generated Instruction Data (JSONL Format Preview):</label>
            <textarea id="output" readonly placeholder="Generated data will appear here..."></textarea>
        </div>
        <div id="status">Status: Ready</div>
    </div>

    <script>
        // Set workerSrc for pdf.js, MUST be served over HTTPS
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;

        // DOM Elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const apiKeyInput = document.getElementById('apiKey');
        const targetPairsInput = document.getElementById('targetPairsInput');
        const modelSelect = document.getElementById('modelSelect');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const outputTextArea = document.getElementById('output');
        const downloadButton = document.getElementById('downloadButton');
        const statusDiv = document.getElementById('status');
        
        // State Variables
        let pdfFiles = [];
        let instructionDataset = [];
        let isProcessing = false;
        let currentPairs = 0;
        let targetPairs = 0;
        const MAX_FILES = 10;
        const PAGES_TO_SKIP_START = 10; // Skips title, contents, intro
        const PAGES_TO_SKIP_END = 5;   // Skips index, bibliography
        const BATCH_SIZE = 5; // Number of concurrent API calls
        const RATE_LIMIT_DELAY = 500; // ms to wait between batches

        // --- File Handling ---
        function handleFiles(files) {
            const newlySelected = Array.from(files).filter(file => file.type === 'application/pdf');
            if (pdfFiles.length + newlySelected.length > MAX_FILES) {
                updateStatus(`Error: Cannot select more than ${MAX_FILES} PDF files.`, true);
                return;
            }
            newlySelected.forEach(newFile => {
                if (!pdfFiles.some(existingFile => existingFile.name === newFile.name)) {
                    pdfFiles.push(newFile);
                }
            });
            renderFileList();
            outputTextArea.value = '';
            instructionDataset = [];
            currentPairs = 0;
            updateStatus(`Ready to process ${pdfFiles.length} file(s).`);
            updateButtonStates();
        }

        function renderFileList() {
            fileList.innerHTML = '';
            pdfFiles.forEach((file, index) => {
                const li = document.createElement('li');
                const fileNameSpan = document.createElement('span');
                fileNameSpan.textContent = `${index + 1}. ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                li.appendChild(fileNameSpan);
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (isProcessing) return;
                    pdfFiles.splice(index, 1);
                    renderFileList();
                    updateStatus(`Removed file. Ready to process ${pdfFiles.length} file(s).`);
                    updateButtonStates();
                };
                li.appendChild(removeBtn);
                fileList.appendChild(li);
            });
        }

        dropZone.addEventListener('dragover', (event) => { event.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (event) => {
            event.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(event.dataTransfer.files);
        });
        fileInput.addEventListener('change', (event) => {
            handleFiles(event.target.files);
            event.target.value = ''; // Reset input to allow re-selection of the same file
        });

        // --- Status & UI Updates ---
        function updateStatus(message, isWarning = false) {
            console[isWarning ? 'warn' : 'log']("Status:", message);
            statusDiv.textContent = `Status: ${message}`;
            statusDiv.style.color = isWarning ? '#ffcc80' : '#bdbdbd';
        }
        
        function updateButtonStates() {
            const hasData = instructionDataset.length > 0;
            const UIElements = [apiKeyInput, targetPairsInput, modelSelect, fileInput, startButton];
            
            startButton.disabled = isProcessing || pdfFiles.length === 0;
            stopButton.disabled = !isProcessing;
            downloadButton.disabled = isProcessing || !hasData;

            UIElements.forEach(el => el.disabled = isProcessing);
            dropZone.style.pointerEvents = isProcessing ? 'none' : 'auto';
            dropZone.style.opacity = isProcessing ? 0.6 : 1;
            fileList.querySelectorAll('button').forEach(btn => btn.disabled = isProcessing);
        }

        // --- Download ---
        function triggerDownload() {
            if (instructionDataset.length === 0) return false;
            try {
                const jsonlString = instructionDataset.map(item => JSON.stringify(item)).join('\n');
                const blob = new Blob([jsonlString], { type: 'application/jsonl' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const modelNameSanitized = modelSelect.value.replace(/[^a-z0-9_-]/gi, '_');
                a.download = `relational_dataset_${currentPairs}_${modelNameSanitized}.jsonl`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                updateStatus(`JSONL file download initiated (${currentPairs} pairs).`);
                return true;
            } catch (error) {
                console.error("Error creating download file:", error);
                updateStatus("Error creating download file.", true);
                return false;
            }
        }
        downloadButton.addEventListener('click', triggerDownload);

        // --- API Call Logic ---
        async function callOpenRouterAPI(apiKey, context, book, templateType) {
            const selectedModel = modelSelect.value;
            const baseURL = "https://openrouter.ai/api/v1";
            const headers = { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" };
            
            // NEW SYSTEM PROMPT
            const systemPrompt = `You are an expert in relationship psychology, specializing in attachment and dynamics as described in books like Attached, Hold Me Tight, The Seven Principles for Making Marriage Work, and The 5 Love Languages. Your task is to transform a raw text segment from a book into a single, concise instruction-response pair in JSON format with 'instruction', 'output', and 'template_type' keys, focusing exclusively on relationship concepts. Avoid non-psychology domains unless they relate to relational applications (e.g., communication, conflict resolution).

For each text chunk, dynamically choose ONE of the following interaction types to ensure variety:
1. Definitional question (e.g., 'Define anxious attachment style.').
2. Scenario-based question (e.g., 'A partner withdraws during arguments. How to respond?').
3. Interpretive question about a behavior (e.g., 'What does stonewalling indicate in relationships?').
4. How-to or application question (e.g., 'What are three ways to build secure attachment?').
5. Comparative question (e.g., 'What is the key difference between love languages and attachment styles?').
6. Real-World Application (e.g., 'Where can I observe the four horsemen in daily interactions?').

Rules:
- Select a different interaction type for each text chunk to maximize variety.
- Generate both the question (instruction) and the answer (output) based on the provided text.
- The response must be grounded exclusively in the provided text; do not invent information.
- Keep the instruction and output clear, accurate, and concise (100-200 tokens total).
- Include a 'template_type' field in the JSON output to indicate the chosen interaction type: 'Define & Explain', 'Analyze & Deconstruct', 'Compare & Contrast', 'Real-World Application', or 'Creative Synthesis'.
- Output a single, valid JSON object with 'instruction', 'output', and 'template_type' keys.

Text chunk:
---
\${context}
---`;
            
            const userPrompt = `Template: ${templateType}
Source: ${book}
Generate the JSON object based on the rules and the text provided in the system prompt.`;

            try {
                const response = await fetch(`${baseURL}/chat/completions`, {
                    method: "POST",
                    headers: headers,
                    body: JSON.stringify({
                        model: selectedModel,
                        messages: [{ role: "system", content: systemPrompt }, { role: "user", content: userPrompt }],
                        response_format: { type: "json_object" }
                    }),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error: ${response.status} - ${errorText}`);
                }

                const completion = await response.json();
                const rawContent = completion.choices[0]?.message?.content?.trim();
                if (!rawContent) throw new Error("API returned an empty response.");

                const parsedJson = JSON.parse(rawContent);
                if (!parsedJson.instruction || !parsedJson.output || !parsedJson.template_type) {
                    throw new Error("Parsed JSON lacks 'instruction', 'output', or 'template_type' keys.");
                }

                return {
                    source_book: book,
                    system: "You are a helpful assistant specialized in relationship psychology, attachment, and dynamics.",
                    instruction: parsedJson.instruction,
                    output: parsedJson.output,
                    template_type: parsedJson.template_type
                };

            } catch (error) {
                console.error(`API/Parsing Error for chunk from "${book}":`, error);
                updateStatus(`API Error: ${error.message}`, true);
                return { error: 'api_or_parse_error', message: error.message };
            }
        }

        // --- PDF Processing & Generation Logic ---
        async function processPDFs(apiKey) {
            // Mapping from the 6 interaction types to the 5 template types for the final JSON
            const promptTypeMapping = [
                { instructionType: "Definitional question", templateType: "Define & Explain" },
                { instructionType: "Scenario-based question", templateType: "Analyze & Deconstruct" },
                { instructionType: "Interpretive question about a behavior", templateType: "Analyze & Deconstruct" },
                { instructionType: "How-to or application question", templateType: "Creative Synthesis" },
                { instructionType: "Comparative question", templateType: "Compare & Contrast" },
                { instructionType: "Real-World Application", templateType: "Real-World Application" }
            ];
            let promptTypeIndex = 0;

            for (const file of pdfFiles) {
                if (!isProcessing) break;
                updateStatus(`Loading PDF: ${file.name}...`);
                const objectUrl = URL.createObjectURL(file);
                let pdfDoc;

                try {
                    pdfDoc = await pdfjsLib.getDocument(objectUrl).promise;
                    updateStatus(`Extracting text from ${file.name} (${pdfDoc.numPages} pages)...`);
                    
                    const startPage = PAGES_TO_SKIP_START + 1;
                    const endPage = Math.max(startPage, pdfDoc.numPages - PAGES_TO_SKIP_END);
                    if (startPage > endPage) {
                        updateStatus(`Skipping ${file.name}: Not enough pages to process.`, true);
                        continue;
                    }

                    let fullText = '';
                    for (let i = startPage; i <= endPage; i++) {
                        const page = await pdfDoc.getPage(i);
                        const textContent = await page.getTextContent();
                        fullText += textContent.items.map(item => item.str).join(' ') + '\n';
                    }
                    fullText = fullText.replace(/\s+/g, ' ').trim();

                    const chunkSize = 2500; // Characters per chunk
                    const textChunks = [];
                    for (let i = 0; i < fullText.length; i += chunkSize) {
                        textChunks.push(fullText.substring(i, i + chunkSize));
                    }
                    updateStatus(`Split ${file.name} into ${textChunks.length} chunks. Starting generation...`);
                    
                    for (let i = 0; i < textChunks.length; i += BATCH_SIZE) {
                        if (!isProcessing) break;

                        const targetDisplay = targetPairs > 0 ? `/${targetPairs}` : '';
                        updateStatus(`Processing batch from ${file.name}... (Total pairs: ${currentPairs}${targetDisplay})`);
                        
                        const batch = textChunks.slice(i, i + BATCH_SIZE);
                        const promises = batch.map(chunk => {
                            // Cycle through the 6 instruction types
                            const { instructionType, templateType } = promptTypeMapping[promptTypeIndex % promptTypeMapping.length];
                            promptTypeIndex++;
                            return callOpenRouterAPI(apiKey, chunk, file.name, instructionType, templateType);
                        });

                        const results = await Promise.all(promises);

                        results.forEach(result => {
                            if (isProcessing && result && !result.error) {
                                instructionDataset.push(result);
                                currentPairs++;
                                if (targetPairs > 0 && currentPairs >= targetPairs) {
                                    isProcessing = false;
                                }
                            }
                        });
                        
                        updateOutput();
                        await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));
                    }
                } catch (pdfError) {
                    updateStatus(`Error processing PDF ${file.name}: ${pdfError.message}.`, true);
                } finally {
                    URL.revokeObjectURL(objectUrl);
                    if (pdfDoc) pdfDoc.destroy();
                }
            }
        }
        
        function updateOutput() {
            const previewData = instructionDataset.slice(-50);
            const previewText = previewData.map(item => JSON.stringify(item)).join('\n');
            outputTextArea.value = `Displaying last ${previewData.length} of ${instructionDataset.length} total pairs...\n\n` + previewText;
            outputTextArea.scrollTop = outputTextArea.scrollHeight;
        }

        // --- Start & Stop Buttons ---
        startButton.addEventListener('click', async () => {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) { updateStatus("Error: API Key is required.", true); return; }
            if (pdfFiles.length === 0) { updateStatus("Error: Please select at least one PDF.", true); return; }
            
            targetPairs = parseInt(targetPairsInput.value, 10) || 0;
            isProcessing = true;
            currentPairs = 0;
            instructionDataset = [];
            outputTextArea.value = '';

            updateButtonStates();
            updateStatus("Starting generation process...");

            try {
                await processPDFs(apiKey);
                if (currentPairs >= targetPairs && targetPairs > 0) {
                    updateStatus(`Target of ${targetPairs} pairs reached. Auto-downloading...`);
                    triggerDownload();
                } else if (!isProcessing) {
                    updateStatus(`Process stopped by user. ${currentPairs} pairs generated.`);
                } else {
                    updateStatus(`Processing finished. ${currentPairs} pairs generated.`);
                }
            } catch (error) {
                 updateStatus(`A critical error occurred: ${error.message}`, true);
            } finally {
                isProcessing = false;
                updateButtonStates();
            }
        });

        stopButton.addEventListener('click', () => {
            if (isProcessing) {
                isProcessing = false; // This flag will stop the processing loops
                updateStatus("Stop requested. Finishing current batch...");
            }
        });

        // --- Initial State ---
        updateButtonStates();
    </script>
</body>
</html>
